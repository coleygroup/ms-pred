from pathlib import Path
import json
import subprocess
from platformdirs import user_cache_dir
from difflib import get_close_matches

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from rdkit import Chem
from rdkit.Chem import Draw

import ms_pred.common as common
from ms_pred.retrieval.retrieval_benchmark import dist_bin


def candidates_from_pubchem(
    formula:str,
    pubchem_form_map:str='data/retrieval/pubchem/pubchem_formulae_inchikey.hdf5',
):
    """
    Get structural candidates with the same chemical formula from pubchem

    Args:
        formula: chemical formula of interested
        pubchem_form_map: path to a pubchem mapping file

    Returns: list of SMILES

    """

    form_to_smi_mapping = common.HDF5Dataset(pubchem_form_map)
    smiles_inchikey = json.loads(form_to_smi_mapping.read_str(formula))
    smiles = [_[0] for _ in smiles_inchikey]

    # remove stereo chemistry and duplicates
    smiles = np.array([common.rm_stereo(smi) for smi in smiles])
    charge = np.array([Chem.GetFormalCharge(Chem.MolFromSmiles(smi)) for smi in smiles])
    smiles = smiles[charge == 0]
    inchikey = [common.inchikey_from_smiles(smi) for smi in smiles]
    _, unique_ids = np.unique(inchikey, return_index=True)
    smiles = smiles[unique_ids]
    return smiles


def iceberg_prediction(
    candidate_smiles:list[str],
    collision_energies:list[int],
    nce:bool=False,
    adduct:str='[M+H]+',
    exp_name:str='iceberg_elucidation',
    python_path:str='',
    gen_ckpt:str='',
    inten_ckpt:str='',
    cuda_devices:int=0,
    batch_size:int=8,
    num_workers:int=6,
    sparse_k:int=100,
    max_nodes:int=100,
    threshold:float=0.1,
    binned_out:bool=False,
    ppm:int=20,
    **kwargs,
):
    """
    Run ICEBERG prediction over a candidate set of molecules

    Args:
        candidate_smiles: (list[str]) list of candidate SMILES
        collision_energies: (list[int]) list of collision energies. Could also be list[list[int]] for each candidate SMILES
        nce: (bool, default=False) if True, the collision energies are treated as normalized collision energy; otherwise, they are treated as absolute eV
        adduct: (str, default='[M+H]+') adduct type. Could also be list[str] for each candidate SMILES
        exp_name: (str, default='iceberg_elucidation') name of the experiment
        python_path: (str) path to python executable
        gen_ckpt: (str) path to ICEBERG generator model (model 1) checkpoint
        inten_ckpt: (str) path to ICEBERG intensity model (model 2) checkpoint
        cuda_devices: (int or list) CUDA visible devices
        batch_size: (int, default=8)
        num_workers: (int, default=6) number of parallel workers
        sparse_k: (int, default=100) number of unique peaks predictred by model 2
        max_nodes: (int, default=100) number of fragments generated by model 1
        threshold: (float, default=0.1) cutoff confidence for model 1
        binned_out: (bool, default=False) if True, model outputs binned spectrum; otherwise, model outputs high-precision m/z peaks
        ppm: (int, default=20) parts-per-million threshold for mass comparison

    Returns: path to results (a temporary path that hashes all experiment parameters),
             precursor mass
    """
    #########################################
    #       Check & preprocess input        #
    #########################################

    python_path = Path(python_path)
    gen_ckpt = Path(gen_ckpt)
    inten_ckpt = Path(inten_ckpt)

    # cuda devices as string
    if isinstance(cuda_devices, list):
        cuda_devices = ','.join([str(_) for _ in cuda_devices])
    elif isinstance(cuda_devices, int):
        cuda_devices = str(cuda_devices)
    assert isinstance(cuda_devices, str)

    # check adduct type
    if isinstance(adduct, str):
        adducts = [adduct] * len(candidate_smiles)
    else:
        adducts = adduct
    for adduct in adducts:
        if not adduct in common.ion2mass:
            matches = get_close_matches(adduct, common.ion2mass.keys(), n=1, cutoff=0.7)
            if len(matches) > 0:
                raise ValueError(f'Unknown adduct {adduct}. Did you mean {matches[0]}? ')
            else:
                raise ValueError(f'Adduct type {adduct} is not supported. Supported adducts: '
                                 f'{list(common.ion2mass.keys())}')
    assert len(adducts) == len(candidate_smiles)

    # remove stereo
    candidate_smiles = [common.rm_stereo(smi) for smi in candidate_smiles]

    # remove duplicate inchikeys
    inchikeys = [common.inchikey_from_smiles(smi) for smi in candidate_smiles]
    _, uniq_idx = np.unique(inchikeys, return_index=True)
    candidate_smiles = np.array(candidate_smiles)[uniq_idx].tolist()
    adducts = np.array(adducts)[uniq_idx].tolist()

    # get formula & mass & check candidate smiles
    # precursor_mass = common.mass_from_smi(candidate_smiles[0]) + common.ion2mass[adduct]
    # # formula check is skipped
    # # formula = common.form_from_smi(candidate_smiles[0])
    # for smi in candidate_smiles:
    #     cur_pm = common.mass_from_smi(smi) + common.ion2mass[adduct]
    #     if np.abs(precursor_mass - cur_pm) > precursor_mass * ppm * 1e-6:  # ppm diff
    #         raise ValueError(f'Precursor mass mismatch in input molecules. Got {smi}, mass={cur_pm}, expected mass={precursor_mass} inferred from {candidate_smiles[0]}')
    #     # if not formula == common.form_from_smi(smi):
    #     #     raise ValueError(f'Formula mismatch in input molecules. Got {smi}, form={common.form_from_smi(smi)}, expected form={formula} inferred from {candidate_smiles[0]}')

    # handle collision energies, convert all nce to ev
    collision_energies = [float(e) for e in collision_energies]
    new_collision_energies = []
    precursor_masses = []
    for cand_smi in candidate_smiles:
        precursor_mass = common.mass_from_smi(cand_smi) + common.ion2mass[adduct]
        precursor_masses.append(precursor_mass)
        if nce:
            ce = [common.nce_to_ev(e, precursor_mass) for e in collision_energies]
        else:
            ce = collision_energies
        new_collision_energies.append([f'{_:.0f}' for _ in sorted(ce)])
    collision_energies = new_collision_energies

    # generate temp directory
    param_str = exp_name + '|'
    for cand_smi, adduct, ce in sorted(zip(candidate_smiles, adducts, collision_energies)):
        param_str += '|' + cand_smi + ';' + str(common.ion2onehot_pos[adduct]) + ';' + ','.join(sorted(ce))
    param_str += '||' + str(gen_ckpt.absolute()) + '||' + str(inten_ckpt.absolute()) + '||' + cuda_devices + \
                 '||' + f'{batch_size:d}-{num_workers:d}-{sparse_k:d}-{max_nodes:d}||' + f'{threshold:.2f}' + \
                 '||' + ('binned_out' if binned_out else "")
    param_hash = common.str_to_hash(param_str)
    save_dir = Path(user_cache_dir(f"ms-pred/iceberg-elucidation/{param_hash}"))
    save_dir.mkdir(parents=True, exist_ok=True)

    #########################################
    #            Call ICEBERG               #
    #########################################

    # skip model call if the results are cached
    if not (save_dir / 'iceberg_run_successful').exists():
        # write candidates to tsv
        entries = []
        for cand_smi, adduct, ce, pmz in zip(candidate_smiles, adducts, collision_energies, precursor_masses):
            entries.append({
                'spec': exp_name, 'smiles': cand_smi, 'ionization': adduct, 'inchikey': common.inchikey_from_smiles(cand_smi),
                'precursor': pmz, 'collision_energies': ce,
            })
        df = pd.DataFrame.from_dict(entries)
        df.to_csv(save_dir / f'cands_df_{exp_name}.tsv', sep='\t', index=False)

        # run iceberg to generate in-silico spectrum
        cmd = (f'''CUDA_VISIBLE_DEVICES={cuda_devices} {python_path} src/ms_pred/dag_pred/predict_smis.py \\
               --batch-size {batch_size} \\
               --num-workers {num_workers} \\
               --dataset-labels {save_dir / f"cands_df_{exp_name}.tsv"} \\
               --sparse-out \\
               --sparse-k {sparse_k} \\
               --max-nodes {max_nodes} \\
               --threshold {threshold} \\
               --gen-checkpoint {gen_ckpt} \\
               --inten-checkpoint {inten_ckpt} \\
               --save-dir {save_dir} \\
               --gpu \\
               --adduct-shift''')
        assert not binned_out, 'Elucidation not supported for binned_out=True'
        if binned_out:
            cmd += ' \\           --binned_out'
        print(cmd)
        run_result = subprocess.run(cmd, shell=True)
        if run_result.returncode == 0:  # successful
            (save_dir / 'iceberg_run_successful').touch()

    precursor_mass = np.unique(np.array(precursor_masses).round(decimals=6))
    if len(precursor_mass) == 1:
        precursor_mass = precursor_mass.item()

    return save_dir, precursor_mass


def load_real_spec(
    real_spec:str,
    real_spec_type:str,
    precursor_mass:float=None,
    nce:bool=False,
    ppm:int=20,
):
    """
    Args:
        precursor_mass:
        nce:
        ppm:
        num_bins:

    Returns:

    """
    if real_spec_type == 'raw':
        meta = {}
    elif real_spec_type == 'ms':
        real_spec_path = Path(real_spec)
        meta, specs = common.parse_spectra(real_spec_path)
        real_spec = common.process_spec_file(meta, specs, merge_specs=False)
    else:
        raise ValueError(f'Unkown spectrum type {real_spec_type}')

    if 'parentmass' in meta:
        if precursor_mass is not None:
            # check if meta is matched
            if np.abs(precursor_mass - float(meta['parentmass'])) > precursor_mass * ppm * 1e-6:
                raise ValueError(f'Precursor mass is different from loaded spectrum metadata! Got m/z={precursor_mass}, loaded from spec={meta["parentmass"]}')
        else:
            precursor_mass = float(meta['parentmass'])
    assert precursor_mass is not None

    # round collision energy to integer
    real_spec = {float(common.get_collision_energy(k)): v for k, v in real_spec.items()}
    if nce:
        real_spec = {common.nce_to_ev(k, precursor_mass): v for k, v in real_spec.items()}
    real_spec = {f'{k:.0f}': v for k, v in real_spec.items()}
    return real_spec


def load_pred_spec(
    load_dir:str,
    step_collision_energy:bool,
):
    """
    Args:
        load_dir: str
        step_collision_energy: bool

    Returns:

    """
    load_dir = Path(load_dir)

    pred_specs = common.HDF5Dataset(load_dir / 'preds.hdf5')
    pred_spec_ars = []
    pred_smis = []
    pred_frags = []
    # iterate over h5 layers
    for pred_spec_obj in pred_specs.h5_obj.values():
        for smiles_obj in pred_spec_obj.values():
            smi = None
            spec_dict = {}
            frag_dict = {}
            for collision_eng_key, collision_eng_obj in smiles_obj.items():
                if smi is None:
                    smi = collision_eng_obj.attrs['smiles']
                collision_eng_key = common.get_collision_energy(collision_eng_key)
                spec_dict[collision_eng_key] = collision_eng_obj['spec'][:]
                frag_dict[collision_eng_key] = json.loads(collision_eng_obj['frag'][0])

            if step_collision_energy:
                mz_frag_to_tup = {}
                for collision_eng_key in spec_dict.keys():
                    for spec, frag in zip(spec_dict[collision_eng_key], frag_dict[collision_eng_key]):
                        mz, inten = spec
                        mz_frag = f'{mz:.4f}_{frag}'
                        cur_tup = mz_frag_to_tup.get(mz_frag)
                        if cur_tup is None:
                            mz_frag_to_tup[mz_frag] = [mz, inten, frag]
                        else:
                            cur_tup[1] += inten

                merged_spec, merged_frag = [], []
                for tup in mz_frag_to_tup.values():
                    merged_spec.append((tup[0], tup[1]))
                    merged_frag.append(tup[2])
                merged_spec = np.array(merged_spec)
                merged_spec[:, 1] = merged_spec[:, 1] / merged_spec[:, 1].max()
                spec_dict['nan'] = merged_spec  # 'nan' means merged
                frag_dict['nan'] = np.array(merged_frag)

            pred_spec_ars.append(spec_dict)
            pred_frags.append(frag_dict)
            pred_smis.append(smi)
    pred_specs.close()
    pred_specs = np.array(pred_spec_ars)
    smiles = np.array(pred_smis)

    return smiles, pred_specs, pred_frags


def elucidation_over_candidates(
    load_dir:str,
    real_spec:str,
    real_spec_type:str='ms',
    precursor_mass:float=None,
    nce:bool=False,
    step_collision_energy:bool=False,
    mol_name:str="",
    real_smiles:str=None,
    topk:int=10,
    ppm:int=20,
    num_bins:int=15000,
    ignore_precursor:bool=True,
    dist_func:str='entropy',
    **kwargs,
):
    """
    Run elucidation over a candidate set

    Args:
        load_dir: (str) path to result directory (return of function iceberg_prediction)
        real_spec: (str) the real spectrum. Depends on real_spec_type
        real_spec_type: (str, default='ms') 'ms': SIRIUS-style spectrum file (.ms), 'raw': processed dictionary
        precursor_mass: (float) mass of the precursor ion
        nce: (bool, default=False) if True, the collision energies are treated as normalized collision energy; otherwise, they are treated as absolute eV
        step_collision_energy: (bool, default=False) if True, it means step_collision_energy is turned on in the instrument and only one merged spectrum will be returned
        mol_name: (str, default="") name of the molecule and/or experiment
        real_smiles: (str, default=None) the real SMILES, if specified
        topk: (int, default=10) number of candidates returned
        ppm: (int, default=20) parts-per-million threshold for mass comparison
        num_bins: (int, default=15000) number of bins for binned spectrum
        ignore_precursor: (bool, default=True) ignore precursor peak
        dist_func: (str, default='entropy') distance function

    Returns: list of TopK molecules:
        [ (top1 SMILES, entropy distance, true molecule or not),
          (top2 SMILES, entropy distance, true molecule or not),
          ...
          (topK SMILES, entropy distance, true molecule or not),
        ]

    """
    assert isinstance(precursor_mass, float)

    real_spec = load_real_spec(real_spec, real_spec_type, precursor_mass, nce, ppm)
    smiles, pred_specs, pred_frags = load_pred_spec(load_dir, step_collision_energy)

    # transform spec to binned spectrum
    real_binned = {k: common.bin_spectra([v], num_bins)[0] for k, v in real_spec.items()}
    pred_binned_specs = [
        {k: common.bin_spectra([v], num_bins, pool_fn='add')[0] for k, v in s.items()}
        for s in pred_specs]

    # get target inchikey (if any)
    if real_smiles is not None:
        target_inchikey = common.inchikey_from_smiles(common.rm_stereo(real_smiles))
    else:
        target_inchikey = None

    # compute distance
    dist = dist_bin(pred_binned_specs, real_binned, ignore_peak=(precursor_mass - 1) * 10 if ignore_precursor else None,
                    sparse=False, func=dist_func)

    sorted_indices = np.argsort(dist)

    found_true = False
    true_idx = -1
    for rnk, idx in enumerate(sorted_indices):
        d = dist[idx]
        smi = smiles[idx]
        inchikey = common.inchikey_from_smiles(smi)
        if target_inchikey is not None and inchikey in target_inchikey:
            print((f'[{mol_name}] ' if len(mol_name) > 0 else "") + f'Found target mol at {rnk+1}/{len(sorted_indices)}, ent_dist={d:.3f}')
            found_true = True
            true_idx = idx
        if idx >= topk and found_true:
            break
    return [(smiles[i], dist[i], i == true_idx) for i in sorted_indices[:topk]]


def plot_top_mols(
    topk_results,
    sa_score=False,
):
    """
    Turn the output of elucidation_over_candidates into plot

    Args:
        topk_results:

    Returns:
        an image object
    """
    mols = []
    legends = []
    for rnk, (smi, dist, is_true) in enumerate(topk_results):
        mol = Chem.MolFromSmiles(smi)
        mols.append(mol)
        legend_str = f"top{rnk+1} ent_dis={dist:.3f}"
        if sa_score:
            sa = sascorer.calculateScore(mol)
            legend_str += f" SA={sa:.3f}"
        if is_true:
            legend_str += '\ntrue molecule'
        legends.append(legend_str)
    return Draw.MolsToGridImage(mols, molsPerRow=5, subImgSize=(250,250), legends=legends, maxMols=len(mols))


def explain_peaks(
    load_dir:str,
    real_spec:str,
    precursor_mass:float,
    mol_str:str,
    real_spec_type:str='ms',
    mol_type:str='smi',
    num_peaks:int=5,
    nce:bool=False,
    step_collision_energy:bool=False,
    ppm:int=20,
    **kwargs,
):
    """
    Plot experiment spectrum and predicted spectrum head-to-head and explain the peaks using ICEBERG predictions

    Args:
        load_dir: (str) path to result directory (return of function iceberg_prediction)
        real_spec: (str) path to the experimental spectrum (.ms file)
        precursor_mass: (float) mass of the precursor ion
        mol_str: (str) the molecule of interest
        real_spec_type: (str, default='ms') 'ms': SIRIUS-style spectrum file (.ms), 'raw': processed dictionary
        mol_type: (str, default='smi') type of mol_str. Supported values: 'smi' (SMILIES), 'inchi' (InChi), 'mol' (RDKit molecule objedt), 'inchikey' (InChiKey)
        num_peaks: (int, default=5) number of peaks to explain
        nce: (bool, default=False) if True, the collision energies are treated as normalized collision energy; otherwise, they are treated as absolute eV
        step_collision_energy: (bool, default=False) if True, it means step_collision_energy is turned on in the instrument and only one merged spectrum will be returned
        ppm: (int, default=20) parts-per-million threshold for mass comparison
    """
    from matplotlib.offsetbox import (OffsetImage, AnnotationBbox)
    import ms_pred.magma.fragmentation as fragmentation


    real_spec = load_real_spec(real_spec, real_spec_type, precursor_mass, nce, ppm)
    smiles, pred_specs, pred_frags = load_pred_spec(load_dir, step_collision_energy)
    cand_inchikeys = [common.inchikey_from_smiles(common.rm_stereo(smi)) for smi in smiles]

    if mol_type == 'smi':
        inchikey_of_interest = common.inchikey_from_smiles(common.rm_stereo(mol_str, mol_type))
    elif mol_type == 'mol':
        inchikey_of_interest = Chem.MolToInchikey(common.rm_stereo(mol_str, mol_type))
    elif mol_type == 'inchi':
        inchikey_of_interest = Chem.InchiToInchikey(common.rm_stereo(mol_str, mol_type))
    elif mol_type == 'inchikey':
        inchikey_of_interest = mol_str
    else:
        raise ValueError(f'mol_type={mol_type} is not supported')

    if not inchikey_of_interest in cand_inchikeys:
        print('No inchikey matching is found for the compound of interested')
        return

    idx = cand_inchikeys.index(inchikey_of_interest)
    smi = smiles[idx]
    engine = fragmentation.FragmentEngine(smi, mol_str_type='smiles')

    for ce in sorted(real_spec.keys()):
        pred_spec = pred_specs[idx][ce]
        pred_frag = pred_frags[idx][ce]
        common.plot_compare_ms(real_spec[ce], pred_spec, 'experiment', 'predicted',  f'collision energy {ce}eV', dpi=500)  # changed for pdf view. was dpi=500

        plt.gca().set_ylim(-1.1, 1.1)

        counter = 0
        pred_spec[:, 1] = pred_spec[:, 1] / np.max(pred_spec[:, 1])
        for spec, frag in zip(pred_spec, pred_frag):
            mz, inten = spec
            draw_dict = engine.get_draw_dict(frag)
            frag_img = Draw.MolToImage(draw_dict["mol"], highlightAtoms=draw_dict["hatoms"], highlightBonds=draw_dict["hbonds"])
            frag_img = np.concatenate((np.array(frag_img), 255 * np.ones((frag_img.size[0], frag_img.size[1], 1), dtype=np.int8)), axis=-1)
            frag_img = np.where(((frag_img[:, :, :3] == np.array([255, 255, 255])[None, None, :]).sum(axis=-1) == 3)[:, :, None],
                                  np.zeros_like(frag_img), frag_img) # make white background transparent
            imagebox = OffsetImage(frag_img, zoom = 0.1)  # changed for pdf view. was zoom=0.2
            ab = AnnotationBbox(imagebox, (mz, - inten - 0.1), frameon = False)  # changed for pdf view. was -0.1
            plt.gca().add_artist(ab)
            plt.text(mz, - inten - 0.2, f'{mz:.3f}', fontsize=4) # changed for pdf view. was -0.2,font_size=5
            counter += 1
            if counter >= num_peaks:
                break


def modi_finder(
    formula_diff:str,
    load_dir:str,
    mol_str1:str,
    name1:str,
    precursor_mass1:float,
    real_spec1:str,
    real_spec_type1:str,
    name2:str,
    precursor_mass2:float,
    real_spec2:str,
    real_spec_type2:str,
    mol_type1:str='smi',
    topk_peaks:int=10,
    return_thresh:float=0.1,
    nce:bool=False,
    step_collision_energy:bool=False,
    ppm:int=20,
):
    """
    ModiFinder find modification sites between two chemical compounds, whereby their mass spec are obtained and the
    structure of mol1 and the formula difference are known. This implementation of ModiFinder only supports one
    modification site.

    Args:
        formula_diff: the formula difference. Examples: '+O', '-CH2'
        load_dir: path to ICEBERG prediction result
        mol_str1: SMILES/InChI of molecule 1 (type is specified in ``mol_type1``)
        name1: name of molecule 1 (for visualization)
        precursor_mass1: precursor mass of molecule 1
        real_spec1: experiment spectrum of molecule 1
        real_spec_type1: type of spectrum 1 (see documentation for function ``load_real_spec`` for details)
        name2: name of molecule 2 (for visualization)
        precursor_mass2: precursor mass of molecule 2
        real_spec2: experiment spectrum of molecule 2
        real_spec_type2: type of spectrum 2 (see documentation for function ``load_real_spec`` for details)
        mol_type1: (default: 'smi') type of mol_str1. Could be 'smi', 'inchi', 'mol', 'inchikey'
        topk_peaks: (default: 10) top k peaks considered to score the modification sites
        return_thresh: (default: 0.1) all sites higher than the score of max(scores) - return_thresh will be highlighted.
            A larger return_thresh will result in more highlighted atoms.
        nce: (bool, default=False) if True, the collision energies are treated as normalized collision energy; otherwise, they are treated as absolute eV
        step_collision_energy: (bool, default=False) if True, it means step_collision_energy is turned on in the instrument and only one merged spectrum will be returned
        ppm: (int, default=20) parts-per-million threshold for mass comparison

    Returns: A plot of most possible modification sites

    """
    from matplotlib.offsetbox import (OffsetImage, AnnotationBbox)
    import ms_pred.magma.fragmentation as fragmentation

    real_spec1 = load_real_spec(real_spec1, real_spec_type1, precursor_mass1, nce, ppm)
    real_spec2 = load_real_spec(real_spec2, real_spec_type2, precursor_mass2, nce, ppm)

    # find peak matching with formula difference
    if formula_diff[0] == '-':
        mass_diff = -common.formula_mass(formula_diff[1:])
    elif formula_diff[0] == '+':
        mass_diff = common.formula_mass(formula_diff[1:])
    else:
        raise ValueError('formula_diff has to start with \'+\' or \'-\'!')
    assert np.abs(precursor_mass1 + mass_diff - precursor_mass2) < precursor_mass1 * 1e-6 * ppm

    interested_peaks = {}
    for ce, spec2 in real_spec2.items():
        cur_matched_peaks = []
        for mz, inten in spec2:
            shifted_mz_in_spec_a = np.min(np.abs(mz - real_spec1[ce][:, 0] - mass_diff)) / mz < 1e-6 * ppm
            mz_in_spec_a = np.min(np.abs(mz - real_spec1[ce][:, 0])) / mz < 1e-6 * ppm
            if shifted_mz_in_spec_a:
                if mz_in_spec_a:
                    a_idx = np.where(np.abs(mz - real_spec1[ce][:, 0]) / mz < 1e-6 * ppm)[0][0]
                    a_mz, a_inten = real_spec1[ce][a_idx]
                    if inten > a_inten:
                        cur_matched_peaks.append((mz, inten - a_inten))
                else:
                    cur_matched_peaks.append((mz, inten))
        interested_peaks[ce] = np.array(cur_matched_peaks)

    smiles, pred_specs, pred_frags = load_pred_spec(load_dir, step_collision_energy)
    cand_inchikeys = [common.inchikey_from_smiles(common.rm_stereo(smi)) for smi in smiles]

    if mol_type1 == 'smi':
        inchikey_of_interest = common.inchikey_from_smiles(common.rm_stereo(mol_str1, mol_type1))
    elif mol_type1 == 'mol':
        inchikey_of_interest = Chem.MolToInchikey(common.rm_stereo(mol_str1, mol_type1))
    elif mol_type1 == 'inchi':
        inchikey_of_interest = Chem.InchiToInchikey(common.rm_stereo(mol_str1, mol_type1))
    elif mol_type1 == 'inchikey':
        inchikey_of_interest = mol_str1
    else:
        raise ValueError(f'mol_type={mol_type1} is not supported')

    if not inchikey_of_interest in cand_inchikeys:
        print('No inchikey matching is found for the compound of interested')
        return

    idx = cand_inchikeys.index(inchikey_of_interest)
    smi = smiles[idx]
    engine = fragmentation.FragmentEngine(smi, mol_str_type='smiles')

    modi_site_imgs = []
    for ce, int_peaks in interested_peaks.items():
        # find peak matching and plot peaks
        peak_matching = np.abs(int_peaks[:, 0][:, None] - real_spec2[ce][:, 0][None, :]) < int_peaks[:, 0][:, None] * 1e-6 * ppm
        common.plot_compare_ms(int_peaks, real_spec2[ce], name1 + f'{formula_diff}', name2, f'# of matched peaks={np.sum(peak_matching.max(axis=-1))}', dpi=500)

        # find fragments to peaks
        counter = 0
        pred_specs[idx][ce][:, 1] = pred_specs[idx][ce][:, 1] / np.max(pred_specs[idx][ce][:, 1])
        sorted_idx = np.argsort(int_peaks[:, 1])[::-1]
        atom_scores = np.zeros(engine.natoms)
        for i in sorted_idx:
            mz, inten = int_peaks[i]
            peak_matching = np.abs(mz - mass_diff - pred_specs[idx][ce][:, 0]) < mz * 1e-6 * ppm
            plot_count = 0
            covered_bitmap = 0
            for j in np.where(peak_matching)[0]:
                covered_bitmap = covered_bitmap | pred_frags[idx][ce][j]  # bit-wise OR
                draw_dict = engine.get_draw_dict(pred_frags[idx][ce][j])
                frag_img = Draw.MolToImage(draw_dict["mol"], highlightAtoms=draw_dict["hatoms"], highlightBonds=draw_dict["hbonds"])
                frag_img = np.concatenate((np.array(frag_img), 255 * np.ones((frag_img.size[0], frag_img.size[1], 1), dtype=np.int8)), axis=-1)
                frag_img = np.where(((frag_img[:, :, :3] == np.array([255, 255, 255])[None, None, :]).sum(axis=-1) == 3)[:, :, None],
                                      np.zeros_like(frag_img), frag_img) # make white background transparent
                imagebox = OffsetImage(frag_img, zoom = 0.15)
                ab = AnnotationBbox(imagebox, (mz, inten + plot_count * 0.15), frameon = False)
                plt.gca().add_artist(ab)
                plot_count += 1
            covered_atoms = engine.get_present_atoms(covered_bitmap)[0]
            if len(covered_atoms) == 0:
                print(f'Uncovered peak: {mz:.5f}, {inten:.2f}')
            else:
                print(f'Covered peak: {mz:.5f}, {inten:.2f}')
            atom_scores[covered_atoms] += inten
            counter += 1
            if counter >= topk_peaks:
                break

        # draw modification site
        img = Draw.MolToImage(engine.mol, highlightAtoms=(np.where(atom_scores > atom_scores.max() - return_thresh)[0]).tolist())
        modi_site_imgs.append(img)

    return modi_site_imgs
